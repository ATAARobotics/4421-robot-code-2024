package frc.robot.commands;import edu.wpi.first.math.MathUtil;import edu.wpi.first.math.controller.PIDController;import edu.wpi.first.math.controller.ProfiledPIDController;import edu.wpi.first.math.controller.SimpleMotorFeedforward;import edu.wpi.first.math.estimator.PoseEstimator;import edu.wpi.first.math.filter.SlewRateLimiter;import edu.wpi.first.math.geometry.Pose2d;import edu.wpi.first.math.geometry.Rotation2d;import edu.wpi.first.math.geometry.Translation2d;import edu.wpi.first.math.trajectory.TrapezoidProfile.Constraints;import edu.wpi.first.math.util.Units;import edu.wpi.first.wpilibj.DriverStation;import edu.wpi.first.wpilibj.DriverStation.Alliance;import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;import edu.wpi.first.wpilibj2.command.Command;import edu.wpi.first.wpilibj2.command.CommandBase;import frc.robot.Constants;import frc.robot.subsystems.Swerve;public class TurnToAmp extends Command {private Swerve m_swerveDriveSubsystem;private PoseEstimator poseEstimator;private Pose2d robotPose;private Pose2d BluegoalPose =  new Pose2d((72.5/39.37), (323.00/39.37) - 0.5, Rotation2d.fromDegrees(270));private Pose2d RedgoalPose = new Pose2d((578.77/39.37), (323.00/39.37) - 0.5, Rotation2d.fromDegrees(270));private Pose2d goalPose = (DriverStation.getAlliance().get()==Alliance.Red) ? RedgoalPose : BluegoalPose;private double rotSpeed;private double rotLimit;private final PIDController rotController = new PIDController(Constants.Subsystems.rotationPID.kP, Constants.Subsystems.rotationPID.kI, Constants.Subsystems.rotationPID.kD);private final SimpleMotorFeedforward feedforward = new SimpleMotorFeedforward(Constants.Swerve.Waypoint.driveKS, Constants.Swerve.Waypoint.driveKV);public TurnToAmp(Swerve swerveDriveSubsystem, PoseEstimator poseEstimator, double driveTolerance, double rotTolerance, double speedLimit, double rotLimit) {this.m_swerveDriveSubsystem = swerveDriveSubsystem;this.poseEstimator = poseEstimator;rotController.enableContinuousInput(-Math.PI, Math.PI);this.rotLimit = 3*Math.PI;rotController.setIZone(Constants.Subsystems.rotationPID.iZone);addRequirements(this.m_swerveDriveSubsystem);}public TurnToAmp(Swerve swerveDriveSubsystem) {this(swerveDriveSubsystem, swerveDriveSubsystem.getPoseEstimator(), Constants.Swerve.Waypoint.E_DTOLERANCE, Constants.Swerve.Waypoint.E_RTOLERANCE, Constants.Swerve.Waypoint.SPEEDLIMIT, Constants.Swerve.Waypoint.ROTLIMIT);}@Override public void initialize() {goalPose = (DriverStation.getAlliance().get()==Alliance.Red) ? RedgoalPose : BluegoalPose;m_swerveDriveSubsystem.setBrakes(true);rotController.setTolerance(Units.degreesToRadians(Constants.Swerve.Waypoint.RTOLERANCE));rotController.setSetpoint(goalPose.getRotation().getRadians());}@Override public void execute() {robotPose = poseEstimator.getEstimatedPosition();rotSpeed = MathUtil.clamp(rotController.calculate(m_swerveDriveSubsystem.getYaw().getRadians()), -rotLimit, rotLimit);double xVel = m_swerveDriveSubsystem.getVelocity().getX();double yVel = m_swerveDriveSubsystem.getVelocity().getY();m_swerveDriveSubsystem.drive(new Translation2d(feedforward.calculate(xVel), feedforward.calculate(yVel)),rotSpeed,true,true);}@Override public boolean isFinished() {return rotController.atSetpoint();}}